#! /usr/local/env python

import sys

class BasePlatformConfig:
	def __init__(self):
		self.defines = []
		self.cxxflags = []
		self.linkflags = []

	def union(self, other):
		self.defines += other.defines
		self.cxxflags += other.cxxflags
		self.linkflags += other.linkflags

	def export(self, ctx):
		ctx.env.append_unique("DEFINES", self.defines)
		ctx.env.append_unique("CXXFLAGS", self.cxxflags)
		ctx.env.append_unique("LINKFLAGS", self.linkflags)

class MatchableConfig(BasePlatformConfig):
	def __init__(self, name, platform=None, buildType=None, compiler=None, defines=[], cxxflags=[], linkflags=[]):
		super().__init__()
		self.name = name
		self.platform = platform
		self.buildType = buildType
		self.compiler = compiler

		self.defines += defines
		self.cxxflags += cxxflags
		self.linkflags += linkflags

	def description(self):
		components = \
		[
			self.__description("platform", self.platform),
			self.__description("buildType", self.buildType),
			self.__description("compiler", self.compiler)
		]

		return self.name + "(" + (" AND ".join([item for item in components if item is not None])) + ")"

	def matches(self, ctx):
		return self.__matches(self.platform, sys.platform) and \
			   self.__matches(self.buildType, ctx.env.BUILD_TYPE) and \
			   self.__matches(self.compiler, ctx.env.CXX_NAME)

	def __description(self, propName, propValue):
		if propValue is None:
			return None

		matchType = "="
		toMatch = ""

		if isinstance(propValue, tuple):
			toMatch = propValue[0]

			if not propValue[1]:
				matchType = "!="
		else:
			toMatch = propValue

		return propName + matchType + toMatch

	def __matches(self, prop, compareValue):
		if prop is None:
			# Always matches.
			return True
		if isinstance(prop, tuple):
			# If the second item in the tuple is False, the match is inverted.
			match = prop[0] == compareValue
			return match if prop[1] else not match
		else:
			# Straightforward match.
			return prop == compareValue

APPNAME = "nightfire-model-converter"

CONFIGS = \
[
	MatchableConfig(
		"DebugConfig",
		buildType="debug",
		defines=["DEBUG", "_DEBUG"]
	),

	MatchableConfig(
		"MSVCConfig",
		compiler="msvc",
		cxxflags=["/EHsc"]
	),

	MatchableConfig(
		"GCCConfig",
		compiler="gcc",
		cxxflags=["-g", "-fvisibility=hidden", "-fdiagnostics-color=always", "-Werror", "-Wno-format-truncation"],
		linkflags=["-Wl,--no-undefined"]
	),

	MatchableConfig(
		"MSVCConfigDebug",
		compiler="msvc",
		buildType="debug",
		cxxflags=["/MDd", "/ZI", "/FS"],
		linkflags=["/DEBUG:FASTLINK"]
	),

	MatchableConfig(
		"GCCConfigDebug",
		compiler="gcc",
		buildType="debug",
		cxxflags=["-Og"]
	),

	MatchableConfig(
		"WindowsSpecificConfig",
		platform="win32",
		defines=[r'PATH_SEP="\\"']
	),

	MatchableConfig(
		"NonWindowsConfig",
		platform=("win32", False),
		defines=['PATH_SEP="/"']
	)
]

def options(ctx):
	grp = ctx.get_option_group('Utilities options')

	grp.add_option('--disable-utils-nfmc',
				   action='store_true',
				   dest='DISABLE_UTILS_NFMC',
				   default=False,
				   help='disable nightfire model converter utility [default: %default]')

def configure(ctx):
	ctx.env.DISABLE_UTILS_NFMC = ctx.options.DISABLE_UTILS_NFMC

def build(bld):
	if bld.env.DISABLE_UTILS_NFMC:
		return

	bld.program(source=bld.path.ant_glob("src/**/*.cpp"),
				target="nightfire-model-converter",
				includes=["src"])
